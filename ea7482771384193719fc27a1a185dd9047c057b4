{
  "comments": [
    {
      "key": {
        "uuid": "def423d3_003365ea",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/health/HealthServlet.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-11-17T12:34:02Z",
      "side": 1,
      "message": "Our implementation persist the health status into a file. Actually health status is return based on existence of the file. If the file exist, unhealthy otherwise healthy.\n\nThis offers 2 advantages:\n-a node can be marked unhealthy even when unresponsive\n-typical use case is to mark node unhealthy, troubleshoot, restart, make sure node is ok and then mark it as healthy. The file allows to persist the unhealthy state across restart.\n\nThat said, I like the idea of setting the state using REST API.\n\nMaybe we can combine both ideas. I will work on that when I get into the office today.",
      "revId": "ea7482771384193719fc27a1a185dd9047c057b4",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c72e824_c5093be2",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/health/HealthServlet.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-11-17T18:34:42Z",
      "side": 1,
      "message": "Done, PS2 use a file in plugin data dir to persist the unhealthy state and I added unit tests also.",
      "parentUuid": "def423d3_003365ea",
      "revId": "ea7482771384193719fc27a1a185dd9047c057b4",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "951392ac_c134595e",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/health/HealthServlet.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1011123
      },
      "writtenOn": "2017-11-20T04:02:14Z",
      "side": 1,
      "message": "\u003e a node can be marked unhealthy even when unresponsive\n\nIf a node is unresponsive won\u0027t it already be considered unhealthy after not responding to the healthcheck call from HAProxy?\n\n\u003e allows to persist the unhealthy state across restart\n\nGood point.  I hadn\u0027t considered that in my basic implementation.",
      "parentUuid": "0c72e824_c5093be2",
      "revId": "ea7482771384193719fc27a1a185dd9047c057b4",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "121eb6d0_ceaea94b",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/health/HealthServlet.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-11-21T01:34:41Z",
      "side": 1,
      "message": "\u003e \u003e a node can be marked unhealthy even when unresponsive\n \u003e \n \u003e If a node is unresponsive won\u0027t it already be considered unhealthy\n \u003e after not responding to the healthcheck call from HAProxy?\n \nI meant Gerrit could be blocked somehow but tcp check from HAProxy still responding.\n\nExample(real one from 2.14): account cache have a bug where it get locked forever and all threads accessing it will be blocked. Http thread pool will eventually be depleted so it will be impossible to tell health server to mark it offline.\n\nI know, this is unlikely so that\u0027s why I think the endpoint to control the server\u0027s health is nice but we need a back door which the file offer us.",
      "parentUuid": "951392ac_c134595e",
      "revId": "ea7482771384193719fc27a1a185dd9047c057b4",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}