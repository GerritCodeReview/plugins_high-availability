{
  "comments": [
    {
      "key": {
        "uuid": "0445fc8e_ef9bca56",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-03-15T17:47:00Z",
      "side": 1,
      "message": "As discussed, let\u0027s just try to support this use case for now. This can be done by injecting Provider\u003cPeerInfo\u003e in HttpSession instead of PeerInfo directly.\n\nWith the auto discovery, even when the peer is disconnected, provider of PeerInfo will keep returning the last know IP/hostname of the peer until the peer reconnect, with same IP/hostname or not.\n\nIn the case where the peer disconnect and reconnect with a different IP/hostname, forwarding will keep trying to the last known peer until PeerInfo provider returns the peer new IP/hostname.",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 13,
        "endChar": 39
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b57d9d7b_15b1d0e6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-03-15T17:54:31Z",
      "side": 1,
      "message": "\u003e As discussed, let\u0027s just try to support this use case for now.\n\nAgreed.\n\n\u003e With the auto discovery, even when the peer is disconnected, provider of PeerInfo will keep returning the last know IP/hostname of the peer until the peer reconnect, with same IP/hostname or not.\n\nOK, this part is easy...\n\n\u003e \n\u003e In the case where the peer disconnect and reconnect with a different IP/hostname, forwarding will keep trying to the last known peer until PeerInfo provider returns the peer new IP/hostname.\n\nDoes this help?\nWhen the PeerInfo provider return the new IP/hostname the missed events will not be forwarded.",
      "parentUuid": "0445fc8e_ef9bca56",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 13,
        "endChar": 39
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9970feba_ea2ac5ff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-03-15T18:12:49Z",
      "side": 1,
      "message": "\u003e Does this help?\n \u003e When the PeerInfo provider return the new IP/hostname the missed\n \u003e events will not be forwarded.\n\nLet\u0027s say active is forwarding to passive which have ip 1.2.3.4.\n-At one point passive dies.\n-Events are still sent to 1.2.3.4 but the http calls will fails since 1.2.3.4 is not available.\n-Events are piling up.\nPassive reconnect with ip 5.6.7.8.\n-Pile up of events are forwarded to passive successfully",
      "parentUuid": "b57d9d7b_15b1d0e6",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 13,
        "endChar": 39
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f186c18a_ea8ba5f1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-03-15T18:20:12Z",
      "side": 1,
      "message": "\u003e \u003e Does this help?\n\u003e  \u003e When the PeerInfo provider return the new IP/hostname the missed\n\u003e  \u003e events will not be forwarded.\n\u003e \n\u003e Let\u0027s say active is forwarding to passive which have ip 1.2.3.4.\n\u003e -At one point passive dies.\n\u003e -Events are still sent to 1.2.3.4 but the http calls will fails since 1.2.3.4 is not available.\n\u003e -Events are piling up.\n\n\u003e Passive reconnect with ip 5.6.7.8.\n\u003e -Pile up of events are forwarded to passive successfully\n\nOh... nice if this will work! Is this a feature of the apache http client?\nWill this already work or do we need to do something?\n\nI always thought that the retry is based on the target URL/IP, but looks like I was wrong.",
      "parentUuid": "9970feba_ea2ac5ff",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 13,
        "endChar": 39
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "440efe56_e7f3a848",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-03-15T15:01:09Z",
      "side": 1,
      "message": "This is breaking the main use case of this plugin.\n\nCurrently, we only support one other configured peer and if we expect it to be there and available. In case the peer goes offline for any reason, the RestForwarder retry forwarding events(the number of retries and delay between them is configurable).\n\nOn our side, we configured both values so it will only stop retrying after the peer was offline for one hour. In case we have an issue with one of the masters, we can take it offline for up to one hour without having to do any kind of manual resync of the secondary indexes and flushing caches. The events forwarding will pile up of the active peer and when the  other peer is brought back online, all piled up events will be forwarded.\n\nIf we want to proceed with your proposed change (stop forwarding when peer goes offline), we need a mechanism to resync a peer that went offline.",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5b735efc_55a94fce",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-03-15T16:14:56Z",
      "side": 1,
      "message": "\u003e This is breaking the main use case of this plugin.\n\u003e \n\u003e Currently, we only support one other configured peer and if we expect it to be there and available. In case the peer goes offline for any reason, the RestForwarder retry forwarding events(the number of retries and delay between them is configurable).\n\nActually the retry logic is in the HttpClientProvider and CloseableHttpClient. Right?\nIIUC, the RestForwarder itself is unaware of any retry logic.\nHowever, if it doesn\u0027t try to forward an event the http client will not know about it\nand there will be no retry.\n\n\u003e If we want to proceed with your proposed change (stop forwarding when peer goes offline), we need a mechanism to resync a peer that went offline.\n\nEven more: the peer that went offline, may start on a different VM and the http client doesn\u0027t know that it has\nto retry for the new URL of the other peer.\nActually, this issue is just a special case of the setup with N \u003e\u003d0  peers with auto discovery, where both N\nand each peer URL can change at the runtime.\n\nIt looks to me that in such case, the retry logic at the http client level is not enough.\n\nResyncing a peer sounds like a good proposal. Just in that case, we would need to pile up last events for a configured\namount of time, even when forwarding to existing peers works. Then when a new peer joins the group, it receives\nall pilled up events. The assumption here is that the newly joined peer cannot be older than the oldest pilled up event.\n\nBtw, the functionality of resyncing a (new) peer is a precondition for adding a new peer to the existing group.\n\nIt seems like the functionality of resyncing a new peer would be a more intrusive change.\nI will think about it over night :-)\n\nAny further ideas/comments are welcome.",
      "parentUuid": "440efe56_e7f3a848",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f2dbb33_753e459b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-03-15T17:22:58Z",
      "side": 1,
      "message": "\u003eActually the retry logic is in the HttpClientProvider and CloseableHttpClient. Right?\n\nYes I meant the forwarding using REST as a general concept, not the RestForwarder class itself. I should have been more clear.\n\nCurrently, the plugin works only in failover mode with 2 peers. The assumption is before installing this plugin, both peers must have the same info, i.e, they share repositories, database, they each have a copy of the secondary index and the caches. Once this is true, then this plugin can be installed and both peer brought online and from this point on, the will be maintained synchronized (caches, indexes and stream events).\n\nAdding support for n peers is something but adding the support   to join a un-synchronized peer is a big challenge. Honestly, the biggest issue is secondary index, the caches problem could  be solved by simply flushing them on new new peer joining. I think that ElasticSearch support in Gerrit is mandatory before we consider support joining a new un-synchronized peer.\n\nLet\u0027s go back to the immediate problem you need to solve. If I understand correctly, you will have 2 masters running on 2 different machine/VM but the problem is you do not know the IPs/hostnames in advance. After the initial discovery, it could be possible that one of the 2 peers rejoin  with a different IP/hostname. Is this your main/only problem so far?",
      "parentUuid": "5b735efc_55a94fce",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "07efa5c6_282fc076",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-03-15T17:31:00Z",
      "side": 1,
      "message": "\u003e \u003eActually the retry logic is in the HttpClientProvider and CloseableHttpClient. Right?\n\u003e \n\u003e Yes I meant the forwarding using REST as a general concept, not the RestForwarder class itself. I should have been more clear.\n\u003e \n\u003e Currently, the plugin works only in failover mode with 2 peers. The assumption is before installing this plugin, both peers must have the same info, i.e, they share repositories, database, they each have a copy of the secondary index and the caches. Once this is true, then this plugin can be installed and both peer brought online and from this point on, the will be maintained synchronized (caches, indexes and stream events).\n\u003e \n\u003e Adding support for n peers is something but adding the support   to join a un-synchronized peer is a big challenge. Honestly, the biggest issue is secondary index, the caches problem could  be solved by simply flushing them on new new peer joining. I think that ElasticSearch support in Gerrit is mandatory before we consider support joining a new un-synchronized peer.\n\nHaving N peers is not my first priority. We can postpone this topic for some time.\nJust for the sake of discussion: Even without the elastic search we could create another peer by stopping\nan inactive instance, making a copy of it (including a copy of the lucene index), and then start both of them.\nIn principle both of them missed the same number of events. If we can resynx the inactive instance when\nit starts, then we could also resync the newly created instance by forwarding exactly the same set of\nevents.\nAs said, this is not really my priority right now.\n\n\u003e \n\u003e Let\u0027s go back to the immediate problem you need to solve. If I understand correctly, you will have 2 masters running on 2 different machine/VM but the problem is you do not know the IPs/hostnames in advance. After the initial discovery, it could be possible that one of the 2 peers rejoin  with a different IP/hostname. Is this your main/only problem so far?\n\nYes, exactly. This is the only real issue I have right now.",
      "parentUuid": "7f2dbb33_753e459b",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 43
      },
      "revId": "51fdd0c769e8dc4935525b05f67659b52b104fb1",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}