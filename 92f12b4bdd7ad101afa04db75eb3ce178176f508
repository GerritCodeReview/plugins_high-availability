{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "151195a1_1d56314d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 7,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T10:50:18Z",
      "side": 1,
      "message": "I think this subject doesn\u0027t properly indicate the main issue that is being addressed with this change which is that some indexing events are retried up to the max number of retries even when it is known that the up-to-date check will never succeed (in the way it is currently implemented).",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10f95af3_27c2b059",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 7,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2024-04-23T19:52:33Z",
      "side": 1,
      "message": "I think showing an example will make things cleaner, let\u0027s imagine that:\n\n1. The current tip of the ref SHA1 is `A1`.\n2. We receive an event to reindex the ref, and the tip SHA1 should be `A2`.\n3. We check if that is true, but in our case, it\u0027s not because the SHA1 is still `A1`(this can happen because of the NFS caching), so we index anyway and we back off for 10 seconds to check if we see correct data.\n4. During that 10 seconds, we have another update to `A3`.\n5. After the backoff, the task checks if the tip SHA1 is `A2`, but in our case, it\u0027s already `A3`, so the task will index current state and back off for another 10 seconds.\n6. Repeat point 5 up to maximum retries.\n\nAnother use case would be that sending/consuming events is slow, so before we consume the event for `A2`, the ref is already pointing to A3.\n\nIn the meantime, we have an event to reindex SHA1 `A3`, and this one is successful. The problem is that we still have a task for `A2` which is retrying and consuming resources(in a very busy repo we can thousands of those).\n\nProposed solution:\n\n1. If any of the indexing tasks for the ref are successful all previous ones which are retrying can be discarded - it\u0027s because all retrying tasks for that ref are pointing to an outdated SHA1.\n2. If we have a new event and already have a task which is retrying, we know that it will never be successful for the current SHA1, so let\u0027s update the SHA1 to the new one and restart the number of retries.\n\nAn alternative approach would be to check the ref history if `A2` is present but it\u0027s not the tip. If yes, we could discard that task. The problem with that solution is that it would be very expensive to traverse the history.",
      "parentUuid": "151195a1_1d56314d",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1712ee3e_86abf3aa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 7,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-23T22:05:48Z",
      "side": 1,
      "message": "\u003e Proposed solution:\n\u003e \n\u003e 1. If any of the indexing tasks for the ref are successful all previous ones which are retrying can be discarded - it\u0027s because all retrying tasks for that ref are pointing to an outdated SHA1.\n\u003e 2. If we have a new event and already have a task which is retrying, we know that it will never be successful for the current SHA1, so let\u0027s update the SHA1 to the new one and restart the number of retries.\n\nIf I follow correctly, then when 2. is implemented there can be only one retrying task for indexing one change, right? So, if this observation is correct, why would 1. be necessary? In that case 1. describes an impossible scenario?",
      "parentUuid": "10f95af3_27c2b059",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "177a3393_51fe709b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 7,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2024-04-24T10:15:44Z",
      "side": 1,
      "message": "Yes, that\u0027s correct. This change is implementing point 2 and implicitly resolving point 1",
      "parentUuid": "1712ee3e_86abf3aa",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad96c02e_3e086cdb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T10:50:18Z",
      "side": 1,
      "message": "For my understanding, why is that check necessary? Why not just index with the current target-branch state? After all this is what this site sees and has.",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 15,
        "endChar": 23
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04289315_aaa2caef",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2024-04-23T19:52:33Z",
      "side": 1,
      "message": "but we have to make sure that we index the latest state of the change. What if the new commit is not yet visible(for example,because of the NFS caching) if we index the current state we will index old data and the new data would be never indexed.",
      "parentUuid": "ad96c02e_3e086cdb",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 15,
        "endChar": 23
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44d3b98f_6ce1bb89",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T10:50:18Z",
      "side": 1,
      "message": "In the case of pointing to a previous meta-ref commit, why not just index that change in that case? What bad could happen if we simply index the change in that case? To keep the performance better we can also switch to using `reindexIfStale`",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 17,
        "endChar": 15
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1722dfb_5757796c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2024-04-23T19:52:33Z",
      "side": 1,
      "message": "we do reindex, but we want to make sure that we keep retrying until the new data is visible to make sure that we index that data",
      "parentUuid": "44d3b98f_6ce1bb89",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 17,
        "endChar": 15
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff62b5f1_ea135299",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T08:45:09Z",
      "side": 1,
      "message": "Can you elaborate more about how this change intends to achieve that? This would make the review easier.",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 27,
        "endChar": 55
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a414798_ac2b1b45",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T10:50:18Z",
      "side": 1,
      "message": "This is highly prone to race conditions. For example, if there is a pending indexing task which is already stale then it will prevent submitting a new (uo-to-date) indexing that for that change.\n\nI would rather propose to think in a different direction:\n* Always accept indexing tasks\n* If necessary, implement an early exit when a task detects that it is stale and will never be up-to-date. That staleness check shall be implemented in the task itself and, an early exit, shall be done by indicating success back to failsafe executor.",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 27,
        "endChar": 55
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8188139_56509ab7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T11:05:04Z",
      "side": 1,
      "message": "Alternatively, we can also use the Aborts API of the failsafe for an abort before the max retries is reached:\nhttps://failsafe.dev/retry/#aborts",
      "parentUuid": "2a414798_ac2b1b45",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 27,
        "endChar": 55
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "edbc741e_5bea44a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-22T10:49:54Z",
      "side": 1,
      "message": "It looks like this change tries to address to many things at once.\n\nI would concentrate first in making the FailsafeExecutor more customisable (e.g. with custom retries) as one change, or get rid of it if we cannot make any meaningful use of it.\n\nAdding @sasa.zivkov@sap.com to the discussion, as the introduction of the `FailsafeExecutor` came from him and he could have other options or ideas to explore.",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dc513ff_b9f9ef5e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-04-02T08:08:55Z",
      "side": 1,
      "message": "Ping @sasa.zivkov@sap.com ?",
      "parentUuid": "edbc741e_5bea44a1",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa62f4db_8d5410a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 3373360
      },
      "writtenOn": "2024-04-02T23:13:36Z",
      "side": 1,
      "message": "git clone https://gerrit.googlesource.com/homepage",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f1ca0159_a75b90dc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 3373360
      },
      "writtenOn": "2024-04-03T00:17:57Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "0dc513ff_b9f9ef5e",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2fb31aac_d632cc6b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-23T22:05:48Z",
      "side": 1,
      "message": "Just wanted to post another question quickly. This is not a complete response.",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d580c2f_71c20221",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-04-24T12:20:40Z",
      "side": 1,
      "message": "I would like to freeze this discussion as @Saša might have a much better solution to this problem 😊\n\n@sasa.zivkov@sap.com could you contribute your alternative change?",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93619e20_1527e5c6",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/index/ForwardedIndexExecutorProvider.java",
        "patchSetId": 4
      },
      "lineNbr": 65,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T11:31:18Z",
      "side": 1,
      "message": "What happens with the sha-1 checks when squashing multiple events into one? Which sha-1 values will be used for the up-to-date checks?",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3818519_03671487",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/index/ForwardedIndexExecutorProvider.java",
        "patchSetId": 4
      },
      "lineNbr": 68,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2024-03-22T10:49:54Z",
      "side": 1,
      "message": "This would basically invalidate the overall idea of using a `FailsafeExecutor`.\n\nI believe we either have to find a way to still keep using it with its management of max attempts, or just get rid of it altogether and revert the commit that introduced it.\n\nAnother path is to contribute to the `FailsafeExecutor` project a custom retry mechanism.\n\nWDYT?",
      "range": {
        "startLine": 65,
        "startChar": 0,
        "endLine": 68,
        "endChar": 47
      },
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a529d82_0b9e3f21",
        "filename": "src/test/java/com/ericsson/gerrit/plugins/highavailability/forwarder/ForwardedIndexChangeHandlerTest.java",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2024-04-22T08:59:32Z",
      "side": 1,
      "message": "Add tests for the use-cases this change is trying to fix?",
      "revId": "92f12b4bdd7ad101afa04db75eb3ce178176f508",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}