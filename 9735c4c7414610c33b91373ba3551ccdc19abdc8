{
  "comments": [
    {
      "key": {
        "uuid": "9f66238a_a65e6dd1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 14,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "AFAIK, this might be an unlikely case, knowing the interleaved scheduling of each reindex run; right?",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 14,
        "endChar": 16
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e3c3175_b933622d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 14,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-09-12T22:44:00Z",
      "side": 1,
      "message": "This is a real use-case and actually happened in production. This fix resolved the problem.",
      "parentUuid": "9f66238a_a65e6dd1",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 14,
        "endChar": 16
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "46ef6b8a_beeb3714",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 14,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-13T14:54:19Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7e3c3175_b933622d",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 14,
        "endChar": 16
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4fba96b3_ceb5d122",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "Based on my previous comment, the currently passed value of newLastIndexTs will always be equivalent to the lastly written value at line 86 (corresponding to maybeIndexTs or indexTs.getUpdateTs\u0027 here). So this would always return the current newLastIndexTs anyway I think.",
      "range": {
        "startLine": 53,
        "startChar": 23,
        "endLine": 53,
        "endChar": 90
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84918940_266aa1a9",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-13T14:54:19Z",
      "side": 1,
      "message": "(Ack)",
      "parentUuid": "4fba96b3_ceb5d122",
      "range": {
        "startLine": 53,
        "startChar": 23,
        "endLine": 53,
        "endChar": 90
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "785d2803_aa03066f",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-12-17T23:12:49Z",
      "side": 1,
      "message": "Because this is at the beginning, newLastIndexTs is always null, so it can become simply:\n\n   newLastIndexTs \u003d maybeIndexTs.get().",
      "parentUuid": "84918940_266aa1a9",
      "range": {
        "startLine": 53,
        "startChar": 23,
        "endLine": 53,
        "endChar": 90
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e26f01e_5640e3c2",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-12-19T19:32:14Z",
      "side": 1,
      "message": "\u003e Because this is at the beginning, newLastIndexTs is always null, so it can become simply:\n\u003e \n\u003e    newLastIndexTs \u003d maybeIndexTs.get().\n\nnewLastIndexTs is a class object (instance) member, so it gets reused across multiple run() calls -for the same object. So it is null only for the very first time this line gets executed, thus not for all the following executions. This being said, the above code change proposal still applies.",
      "parentUuid": "785d2803_aa03066f",
      "range": {
        "startLine": 53,
        "startChar": 23,
        "endLine": 53,
        "endChar": 90
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11950d1f_d6b9eeef",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-12-30T22:02:30Z",
      "side": 1,
      "message": "\u003e \u003e Because this is at the beginning, newLastIndexTs is always null, so it can become simply:\n\u003e \u003e \n\u003e \u003e    newLastIndexTs \u003d maybeIndexTs.get().\n\u003e \n\u003e newLastIndexTs is a class object (instance) member, so it gets reused across multiple run() calls -for the same object.\n\nThis is a runnable used in a thread and the run() gets called only once.\n\n\u003e So it is null only for the very first time this line gets executed, thus not for all the following executions. \n\nThere are no following executions.\n\n\u003e This being said, the above code change proposal still applies.\n\nI am a bit lost in the thread discussion here: what are you proposing to do here instead? Can you put the code sample?",
      "parentUuid": "9e26f01e_5640e3c2",
      "range": {
        "startLine": 53,
        "startChar": 23,
        "endLine": 53,
        "endChar": 90
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9c91cf3_9eef04e5",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "newLastIndexTs \u003d itemTs.get(), rather?\n\nAFAIK, we already know that itemTs.get() is \"after\" newLastIndexTs here, given that itemTs.isPresent() and how indexIfNeeded returns that timestamp -based on c\u0027s own timestamp and the sinceTs (newLastIndexTs) passed at line 62.\n\nBut then, as we keep looping onto the next change to consider for reindex, we will check if it needs reindexing based on a sinceTs set to the last reindexed change\u0027s timestamp. -Rather than a sinceTs based on the last overall reindex timestamp, AFAIK.\n\nI think this is wrong, as we may skip reindexing a change if its last timestamp was before the previously reindexed change\u0027s own timestamp. (We\u0027d skip it also assuming that its timestamp does come after the last overall index update time.)\n\nAlso, setting newLastIndexTs to itemTs.get() or so here leads to eventually writing the last reindexed change\u0027s timestamp as the updated indexTs (at line 86). This will be wrong if the last reindexed change happens to not be the most recently updated one. -If my understanding of all this is right, that is.",
      "range": {
        "startLine": 65,
        "startChar": 14,
        "endLine": 65,
        "endChar": 73
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c95cd0b_fb969e95",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-09-12T22:44:00Z",
      "side": 1,
      "message": "\u003e newLastIndexTs \u003d itemTs.get(), rather?\n\u003e \n\u003e AFAIK, we already know that itemTs.get() is \"after\" newLastIndexTs here,\n\nNot necessarily: the indexTs on disk gets updated asynchronously and in case of a flooding of notifications the thread that actually writes it to disk may be delayed.\n\n\u003e given that itemTs.isPresent() and how indexIfNeeded returns that timestamp -based on c\u0027s own timestamp and the sinceTs (newLastIndexTs) passed at line 62.\n\u003e \n\u003e But then, as we keep looping onto the next change to consider for reindex, we will check if it needs reindexing based on a sinceTs set to the last reindexed change\u0027s timestamp. -Rather than a sinceTs based on the last overall reindex timestamp, AFAIK.\n\u003e \n\u003e I think this is wrong, as we may skip reindexing a change if its last timestamp was before the previously reindexed change\u0027s own timestamp. (We\u0027d skip it also assuming that its timestamp does come after the last overall index update time.)\n\nThe use-case that is addressing is when the connectivity between the nodes goes down or is massively delayed. Is then assuming that one of the two nodes is behind. What you say is correct, but it is not this use-case.\n\nIt would make sense then to extend the solution to consider other use-cases, like the one you mentioned (change outdated even if its timestamp is before the newLastIndexTs).\n\n\u003e \n\u003e Also, setting newLastIndexTs to itemTs.get() or so here leads to eventually writing the last reindexed change\u0027s timestamp as the updated indexTs (at line 86). This will be wrong if the last reindexed change happens to not be the most recently updated one. -If my understanding of all this is right, that is.",
      "parentUuid": "f9c91cf3_9eef04e5",
      "range": {
        "startLine": 65,
        "startChar": 14,
        "endLine": 65,
        "endChar": 73
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ee0286eb_66f2d104",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-13T14:54:19Z",
      "side": 1,
      "message": "Went through this whole code again, and my only left comment would be the one about replacing line 65 with this one:\n\nnewLastIndexTs \u003d itemTs.get();\n\nI propose so because we already know that itemTs is after newLastIndexTs, time-wise. Why so? Well, because indexIfNeeded() returned it to us here (going through isPresent). And it did so because its c\u0027s TS (itemTs) was deemed being after its sinceTs (newLastIndexTs).\n\nOne may confirm this by revisiting how indexIfNeeded() is implemented in all three ReindexRunnable implementing classes. That is how I understand why we\u0027d now only need to patch this very line (65) -in this current change.",
      "parentUuid": "8c95cd0b_fb969e95",
      "range": {
        "startLine": 65,
        "startChar": 14,
        "endLine": 65,
        "endChar": 73
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "646f96a5_0742994c",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-12-17T23:12:49Z",
      "side": 1,
      "message": "\u003e Went through this whole code again, and my only left comment would be the one about replacing line 65 with this one:\n\u003e \n\u003e newLastIndexTs \u003d itemTs.get();\n\u003e \n\u003e I propose so because we already know that itemTs is after newLastIndexTs, time-wise. Why so? Well, because indexIfNeeded() returned it to us here (going through isPresent).\n\nindexIfNeeded() is abstract and not defined in this class. We can\u0027t assume anything about its implementation then.\n\n\u003e And it did so because its c\u0027s TS (itemTs) was deemed being after its sinceTs (newLastIndexTs).\n\nNot sure how you can be sure on this class. If you read the other classes, maybe, but then you are working on assumptions of other implementations IMHO, opening the door to future bugs :-(\n\nI would rather prefer a more robust code than perfect but fragile one, but that\u0027s my personal preference here.\n\n\u003e One may confirm this by revisiting how indexIfNeeded() is implemented in all three ReindexRunnable implementing classes. That is how I understand why we\u0027d now only need to patch this very line (65) -in this current change.\n\nA base class should never assume and be based on the implementation of the subclasses IMHO.",
      "parentUuid": "ee0286eb_66f2d104",
      "range": {
        "startLine": 65,
        "startChar": 14,
        "endLine": 65,
        "endChar": 73
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "27d5d011_94b602d6",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-12-19T19:32:14Z",
      "side": 1,
      "message": "\u003e \u003e Went through this whole code again, and my only left comment would be the one about replacing line 65 with this one:\n\u003e \u003e \n\u003e \u003e newLastIndexTs \u003d itemTs.get();\n\u003e \u003e \n\u003e \u003e I propose so because we already know that itemTs is after newLastIndexTs, time-wise. Why so? Well, because indexIfNeeded() returned it to us here (going through isPresent).\n\u003e \n\u003e indexIfNeeded() is abstract and not defined in this class. We can\u0027t assume anything about its implementation then.\n\u003e \n\u003e \u003e And it did so because its c\u0027s TS (itemTs) was deemed being after its sinceTs (newLastIndexTs).\n\u003e \n\u003e Not sure how you can be sure on this class. If you read the other classes, maybe, but then you are working on assumptions of other implementations IMHO, opening the door to future bugs :-(\n\u003e \n\u003e I would rather prefer a more robust code than perfect but fragile one, but that\u0027s my personal preference here.\n\u003e \n\u003e \u003e One may confirm this by revisiting how indexIfNeeded() is implemented in all three ReindexRunnable implementing classes. That is how I understand why we\u0027d now only need to patch this very line (65) -in this current change.\n\u003e \n\u003e A base class should never assume and be based on the implementation of the subclasses IMHO.\n\nTrue. However, when I look at the reality of all the involved sub-classes here in this specific case, this is how it happens -systematically. This means to me that the above original (change) code is sub-optimal, at least from such a design perspective.",
      "parentUuid": "646f96a5_0742994c",
      "range": {
        "startLine": 65,
        "startChar": 14,
        "endLine": 65,
        "endChar": 73
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0122d040_21976a88",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-12-30T22:02:30Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Went through this whole code again, and my only left comment would be the one about replacing line 65 with this one:\n\u003e \u003e \u003e \n\u003e \u003e \u003e newLastIndexTs \u003d itemTs.get();\n\u003e \u003e \u003e \n\u003e \u003e \u003e I propose so because we already know that itemTs is after newLastIndexTs, time-wise. Why so? Well, because indexIfNeeded() returned it to us here (going through isPresent).\n\u003e \u003e \n\u003e \u003e indexIfNeeded() is abstract and not defined in this class. We can\u0027t assume anything about its implementation then.\n\u003e \u003e \n\u003e \u003e \u003e And it did so because its c\u0027s TS (itemTs) was deemed being after its sinceTs (newLastIndexTs).\n\u003e \u003e \n\u003e \u003e Not sure how you can be sure on this class. If you read the other classes, maybe, but then you are working on assumptions of other implementations IMHO, opening the door to future bugs :-(\n\u003e \u003e \n\u003e \u003e I would rather prefer a more robust code than perfect but fragile one, but that\u0027s my personal preference here.\n\u003e \u003e \n\u003e \u003e \u003e One may confirm this by revisiting how indexIfNeeded() is implemented in all three ReindexRunnable implementing classes. That is how I understand why we\u0027d now only need to patch this very line (65) -in this current change.\n\u003e \u003e \n\u003e \u003e A base class should never assume and be based on the implementation of the subclasses IMHO.\n\u003e \n\u003e True. However, when I look at the reality of all the involved sub-classes here in this specific case, this is how it happens -systematically. This means to me that the above original (change) code is sub-optimal, at least from such a design perspective.\n\nMy comment in on the SOLID design principles (https://en.wikipedia.org/wiki/SOLID). Which design principles are you referring to by saying that \"code is sub-optimal\"?",
      "parentUuid": "27d5d011_94b602d6",
      "range": {
        "startLine": 65,
        "startChar": 14,
        "endLine": 65,
        "endChar": 73
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "299a3050_539b44be",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 101,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "Not a possible case based on the current calls? -Might be kept still for robustness.",
      "range": {
        "startLine": 98,
        "startChar": 4,
        "endLine": 101,
        "endChar": 0
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6472fc8d_1d985f52",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 101,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-09-12T22:44:00Z",
      "side": 1,
      "message": "Yes, exactly.",
      "parentUuid": "299a3050_539b44be",
      "range": {
        "startLine": 98,
        "startChar": 4,
        "endLine": 101,
        "endChar": 0
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6fe70df2_cde7b646",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 101,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-13T14:54:19Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "6472fc8d_1d985f52",
      "range": {
        "startLine": 98,
        "startChar": 4,
        "endLine": 101,
        "endChar": 0
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}