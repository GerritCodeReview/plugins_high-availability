{
  "comments": [
    {
      "key": {
        "uuid": "9f66238a_a65e6dd1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 14,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "AFAIK, this might be an unlikely case, knowing the interleaved scheduling of each reindex run; right?",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 14,
        "endChar": 16
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fba96b3_ceb5d122",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "Based on my previous comment, the currently passed value of newLastIndexTs will always be equivalent to the lastly written value at line 86 (corresponding to maybeIndexTs or indexTs.getUpdateTs\u0027 here). So this would always return the current newLastIndexTs anyway I think.",
      "range": {
        "startLine": 53,
        "startChar": 23,
        "endLine": 53,
        "endChar": 90
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9c91cf3_9eef04e5",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "newLastIndexTs \u003d itemTs.get(), rather?\n\nAFAIK, we already know that itemTs.get() is \"after\" newLastIndexTs here, given that itemTs.isPresent() and how indexIfNeeded returns that timestamp -based on c\u0027s own timestamp and the sinceTs (newLastIndexTs) passed at line 62.\n\nBut then, as we keep looping onto the next change to consider for reindex, we will check if it needs reindexing based on a sinceTs set to the last reindexed change\u0027s timestamp. -Rather than a sinceTs based on the last overall reindex timestamp, AFAIK.\n\nI think this is wrong, as we may skip reindexing a change if its last timestamp was before the previously reindexed change\u0027s own timestamp. (We\u0027d skip it also assuming that its timestamp does come after the last overall index update time.)\n\nAlso, setting newLastIndexTs to itemTs.get() or so here leads to eventually writing the last reindexed change\u0027s timestamp as the updated indexTs (at line 86). This will be wrong if the last reindexed change happens to not be the most recently updated one. -If my understanding of all this is right, that is.",
      "range": {
        "startLine": 65,
        "startChar": 14,
        "endLine": 65,
        "endChar": 73
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "299a3050_539b44be",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/autoreindex/ReindexRunnable.java",
        "patchSetId": 8
      },
      "lineNbr": 101,
      "author": {
        "id": 1012732
      },
      "writtenOn": "2018-09-12T22:22:52Z",
      "side": 1,
      "message": "Not a possible case based on the current calls? -Might be kept still for robustness.",
      "range": {
        "startLine": 98,
        "startChar": 4,
        "endLine": 101,
        "endChar": 0
      },
      "revId": "9735c4c7414610c33b91373ba3551ccdc19abdc8",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}