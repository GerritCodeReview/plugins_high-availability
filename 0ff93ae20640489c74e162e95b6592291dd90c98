{
  "comments": [
    {
      "key": {
        "uuid": "0b6c5870_91ff65ef",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 15,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-09-30T20:22:20Z",
      "side": 1,
      "message": "This is actually not possible if we think about other node joining the cluster\nafter the message has been sent. I discussed this on jgroups-dev mailing list [1]\n\n[1] https://groups.google.com/d/msg/jgroups-dev/5qnQZtFpA7I/4gZxN7QCAwAJ",
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49df5505_a2bd8818",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-10-01T11:14:32Z",
      "side": 1,
      "message": "Maybe my suggestion of extracting the retry logic out of the http layer was not that good after all. When we will want to rely on JGroups for the retry delivery, the extracted retry logic will become an issue.\n\nI read Bela Ban\u0027s answer and state transfer seems to be the main way for a new JGroup member to get what it missed.\n\nI do not know if this is a good idea I will share anyway:\n\nLet\u0027s assume every node in the cluster knows how many peers there should be (e.g.getting it from the configuration). When something is happening, if numbers of peers in the view is equal to number of expected peer, then just send the message. If number of peers in the view is lower than the number of expected peer, then send the message but also store it the the state so when the other expected nodes connect, they will get what they missed from the state transfer and empty the state.",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 25,
        "endChar": 10
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1dbfda93_24c2be0b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-10-01T19:35:05Z",
      "side": 1,
      "message": "\u003e Maybe my suggestion of extracting the retry logic out of the http layer was not that good after all. When we will want to rely on JGroups for the retry delivery, the extracted retry logic will become an issue.\n\nI am aware that how jgroups is used from this change is likely suboptimal. However, as\nthe very first step I wanted to stay as close as possible to the http based solution which\nis well tested. I believe that we could start with the approach like in this change and\nthen keep improving in small steps until we reach state which is more aligned with the\njgroups idea.\n\n\n\u003e I read Bela Ban\u0027s answer and state transfer seems to be the main way for a new JGroup member to get what it missed.\n\nYes, state transfer would be JGroups compliant approach. But it is also more tricky to\nimplement as the very first step.\n\n\u003e \n\u003e I do not know if this is a good idea I will share anyway:\n\u003e \n\u003e Let\u0027s assume every node in the cluster knows how many peers there should be (e.g.getting it from the configuration). When something is happening, if numbers of peers in the view is equal to number of expected peer, then just send the message.\n\nWe must also check the response(s) and make sure that all peers received the message. Even if all peers were in the view at the moment when we checked, a peer could disappear just before the message is sent.\n\n\u003e If number of peers in the view is lower than the number of expected peer, then send the message but also store it the the state so when the other expected nodes connect, they will get what they missed from the state transfer and empty the state.\n\nI think that it is a bit more complex than you described in case we are talking about a\ngeneric solution which supports N peers.\nFor example, where would the missed messages be collected? There must be an agreement between\npeers on which one is responsible for keeping the state. Maybe jgroups already provides support\nfor this scenario, we need to read the docs.\nFurther, knowing when to empty the state becomes trickier if more than one peer missed some\nmessages. They could have missed different sets of messages. Therefore, the state must\nintroduce some sequence numbers associated to each entry in the state. When a peer joins\nagain it needs to tell which was the last sequence number it received.\nDo we want to maintain global sequence numbers, or one per each message type?\nWe also need to know how many peers missed some messages and when it is safe to clean the state.\nMaybe we have to uniquely identify each peer instead of just counting them?\n\nI believe that all these issues are solvable but it would take us more time to come\nto something productively useable.",
      "parentUuid": "49df5505_a2bd8818",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 25,
        "endChar": 10
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b3c7b0d_440ba750",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-10-01T19:50:45Z",
      "side": 1,
      "message": "\u003e We also need to know how many peers missed some messages and when it is safe to clean the state.\n\u003e Maybe we have to uniquely identify each peer instead of just counting them?\n\nThinking more about this issue I believe that we should never clean the whole state as it is very tricky to know when it is safe to do.\nInstead, the state should simply be a bounded list of last N (configurable) messages. When the state list is full, the oldest entries get automatically dropped.\nWhen a state transfer is requested by a peer, we send the last M missed messages from the list, where M is the number of messages missed by the peer.",
      "parentUuid": "1dbfda93_24c2be0b",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 25,
        "endChar": 10
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a600c58e_04808910",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-10-02T06:55:18Z",
      "side": 1,
      "message": "\u003e \u003e Maybe my suggestion of extracting the retry logic out of the http\n \u003e layer was not that good after all. When we will want to rely on\n \u003e JGroups for the retry delivery, the extracted retry logic will\n \u003e become an issue.\n \u003e \n \u003e I am aware that how jgroups is used from this change is likely\n \u003e suboptimal. However, as\n \u003e the very first step I wanted to stay as close as possible to the\n \u003e http based solution which\n \u003e is well tested. I believe that we could start with the approach\n \u003e like in this change and\n \u003e then keep improving in small steps until we reach state which is\n \u003e more aligned with the\n \u003e jgroups idea.\n \u003e \n\n \nI am totally fine with the current approach. My comment was more about\nwhen we will want to implement a retry within the JGroups layer, maybe\nwe will need to move back the general retry in the http layer.",
      "parentUuid": "1dbfda93_24c2be0b",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 25,
        "endChar": 10
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3f2931c_0daf6c38",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-10-02T07:36:46Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Maybe my suggestion of extracting the retry logic out of the http\n\u003e  \u003e layer was not that good after all. When we will want to rely on\n\u003e  \u003e JGroups for the retry delivery, the extracted retry logic will\n\u003e  \u003e become an issue.\n\u003e  \u003e \n\u003e  \u003e I am aware that how jgroups is used from this change is likely\n\u003e  \u003e suboptimal. However, as\n\u003e  \u003e the very first step I wanted to stay as close as possible to the\n\u003e  \u003e http based solution which\n\u003e  \u003e is well tested. I believe that we could start with the approach\n\u003e  \u003e like in this change and\n\u003e  \u003e then keep improving in small steps until we reach state which is\n\u003e  \u003e more aligned with the\n\u003e  \u003e jgroups idea.\n\u003e  \u003e \n\u003e \n\u003e  \n\u003e I am totally fine with the current approach. My comment was more about\n\u003e when we will want to implement a retry within the JGroups layer, maybe\n\u003e we will need to move back the general retry in the http layer.\n\nMaybe I am missing something, but the retry logic is all within the RestForwarder.Request.\nWe did extract retry logic out of the HTTP client but still kept it within the REST layer.\n\nJGroupsForwarder currently implements own retry logic, which is similar to the REST based retry logic but it is not reusing it. We can remove the retry logic from JGroupsForwarder once\nwe implement JGroups state transfer.",
      "parentUuid": "a600c58e_04808910",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 25,
        "endChar": 10
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b439d1f1_c5408717",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2017-10-02T08:08:33Z",
      "side": 1,
      "message": "You are right, forget my comment, I will blame it on the jet lag :)",
      "parentUuid": "d3f2931c_0daf6c38",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 25,
        "endChar": 10
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59b1dc95_aabe5dd8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-09-30T20:19:15Z",
      "side": 1,
      "message": "This is actually not possible. According to my discussion [1] on the jgroups-dev\nmailing list, JGroups will never deliver already sent message to a node which\njoins the cluster after the message is already sent.\n\n[1] https://groups.google.com/d/msg/jgroups-dev/5qnQZtFpA7I/4gZxN7QCAwAJ",
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a62fb726_f1002084",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-09-30T20:28:19Z",
      "side": 1,
      "message": "We need configurable JGroups channel. This changes uses \"new JChannel()\"\nwhich means: default configuration. JGroups channel provides many constructors\nincluding the one [1] which accepts a property file. We should check existence of\nthe property file at, for example, $SITE/etc/jchannel.properties, and if the\nfile is present use it.\n\n[1] http://www.jgroups.org/javadoc/org/jgroups/JChannel.html#JChannel-java.io.File-",
      "range": {
        "startLine": 70,
        "startChar": 0,
        "endLine": 71,
        "endChar": 50
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a00734b9_b7c5a692",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/Configuration.java",
        "patchSetId": 1
      },
      "lineNbr": 89,
      "author": {
        "id": 1019328
      },
      "writtenOn": "2017-10-01T09:56:57Z",
      "side": 1,
      "message": "Move to jgroups section?",
      "range": {
        "startLine": 89,
        "startChar": 2,
        "endLine": 89,
        "endChar": 51
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d05bcaff_ee14673e",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/Configuration.java",
        "patchSetId": 1
      },
      "lineNbr": 89,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-10-02T07:58:16Z",
      "side": 1,
      "message": "All DEFAULT_* constants were located here at the bottom. You are probably right that these constants should all be moved to their corresponding sections but this issue is not introduced with this change.",
      "parentUuid": "a00734b9_b7c5a692",
      "range": {
        "startLine": 89,
        "startChar": 2,
        "endLine": 89,
        "endChar": 51
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7993fa92_f240ef80",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/Configuration.java",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1019328
      },
      "writtenOn": "2017-10-01T09:56:57Z",
      "side": 1,
      "message": "Same as above?",
      "range": {
        "startLine": 91,
        "startChar": 2,
        "endLine": 91,
        "endChar": 58
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9ff7dde_568d5de5",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/Configuration.java",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-10-02T07:58:16Z",
      "side": 1,
      "message": "Same answer :-)",
      "parentUuid": "7993fa92_f240ef80",
      "range": {
        "startLine": 91,
        "startChar": 2,
        "endLine": 91,
        "endChar": 58
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f0c6bb3_bc1f0781",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/Module.java",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1019328
      },
      "writtenOn": "2017-10-01T09:56:57Z",
      "side": 1,
      "message": "It this intentional?",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 19,
        "endChar": 26
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52fdb5a1_1da80e73",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/Module.java",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-10-01T19:36:06Z",
      "side": 1,
      "message": "No, not intentional. Likely I missed to apply google-java-format before this series.",
      "parentUuid": "2f0c6bb3_bc1f0781",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 19,
        "endChar": 26
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "160f1d1f_e9cce9bc",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/Module.java",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-10-02T08:15:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "52fdb5a1_1da80e73",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 19,
        "endChar": 26
      },
      "revId": "0ff93ae20640489c74e162e95b6592291dd90c98",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}