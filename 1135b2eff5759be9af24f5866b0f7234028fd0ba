{
  "comments": [
    {
      "key": {
        "uuid": "7d14de30_16545a14",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/ChangeReindexRunnable.java",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2018-02-25T07:28:03Z",
      "side": 1,
      "message": "As pointed out by Hugo, the database select approach would only work on stable-2.14 and on non migrated sites to NoteDb on stabe-2.15 and later.\n\nI agree, this feature is a useful addition and is better then the only alternative we have now: full reindexing that is very time consuming for big sites.\n\nForward porting would require the scan of index specific refs \n (accounts, changes, groups). I think this scan should work, as it should only lazy ready minimal part of the change meta data, so that I expect that approach be much faster, then ful reindex.\n\nStill, I think loud about alternative approaches to this suggestion:\n\n* 1. Set up in addition to active and passive nodes, a standalone queue that would always consume reindex events and passive node could query that queue for lost event starting from specific time.\n* 2. Set up the recording mode on the active node, and put the events in addition to some kind of storage: in memory only cache or (better) persistent cache, and set up a REST endpoint and allow the passive node to query the missed events started from specific time.\n* 3. Make the solution 2. as gerrit plugin: reindex-event-recorder-plugin. This plugin, loaded in active node would record the reindex event in a simple database table (even a generic one should work: id, index_type, reindex_time) and given that we already have database dependency in gerrit because of account_patch_reviews, this approach wouldn\u0027t add any new complexity. The passive node, on start, could do two different thing to recover:\n* a) call REST endpoint on the master node exposed by reindex-event-recorder-plugin and ask for the ids for entities to reindex (for specific entity type)\n* b) query the database directly.\n\nSo basically, the alternative solution to full ref scan, once the database gone, is to avoid losing the events.\n\nMy suggestion would be to define Recover-(Lost)-Reindex-Event strategy in this plugin and add additional strategies when different strategies are implemented:\n\n* Full table scan\n* Full ref scan\n* Stadalone Queue\n* Query active node\n* reindex-event-recorder-plugin\n* ...",
      "range": {
        "startLine": 45,
        "startChar": 11,
        "endLine": 45,
        "endChar": 29
      },
      "revId": "1135b2eff5759be9af24f5866b0f7234028fd0ba",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f551f749_fe50c072",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/ChangeReindexRunnable.java",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-02-26T14:23:55Z",
      "side": 1,
      "message": "\u003e As pointed out by Hugo, the database select approach would only work on stable-2.14 and on non migrated sites to NoteDb on stabe-2.15 and later.\n\nYes, however, NoteDb and ReviewDb are inherently different and a \"one-size-fits-all\" solution isn\u0027t possible IMHO. However, happy to accept suggestions and contributions.\n\n \n\u003e I agree, this feature is a useful addition and is better then the only alternative we have now: full reindexing that is very time consuming for big sites.\n\nNot just time consuming, it is a non-solution for an HA configuration.\nHA helps when shit happens and a solution that doesn\u0027t cover the \"shit situation\" isn\u0027t complete, as Hugo acknowledge.\n\n\n\u003e Forward porting would require the scan of index specific refs \n\u003e  (accounts, changes, groups). I think this scan should work, as it should only lazy ready minimal part of the change meta data, so that I expect that approach be much faster, then ful reindex.\n\nYes, possibly the extraction with an interface and two different implementations?\n\n\u003e Still, I think loud about alternative approaches to this suggestion:\n\u003e \n\u003e * 1. Set up in addition to active and passive nodes, a standalone queue that would always consume reindex events and passive node could query that queue for lost event starting from specific time.\n\nYes, but the problem we are trying to solve here is where one of the two nodes is misbehaving but still serving incoming calls.\nIf the master is misbehaving, it could fail as well in submitting events to the queue :-(\n\nWhen the master is healthy and is able to submit events to the failover, we do not have problems at all :-)\n\n\u003e * 2. Set up the recording mode on the active node, and put the events in addition to some kind of storage: in memory only cache or (better) persistent cache, and set up a REST endpoint and allow the passive node to query the missed events started from specific time.\n\nSame comment as above: this doesn\u0027t work when the master is misbehaving.\n\n\u003e * 3. Make the solution 2. as gerrit plugin: reindex-event-recorder-plugin. This plugin, loaded in active node would record the reindex event in a simple database table (even a generic one should work: id, index_type, reindex_time) and given that we already have database dependency in gerrit because of account_patch_reviews, this approach wouldn\u0027t add any new complexity. The passive node, on start, could do two different thing to recover:\n\u003e * a) call REST endpoint on the master node exposed by reindex-event-recorder-plugin and ask for the ids for entities to reindex (for specific entity type)\n\u003e * b) query the database directly.\n\nThis is a very interesting solution: so basically having this as a separate plugin. Makes a lot of sense. However, still not convinced in the \"cooperation\" of the master node, as we are trying to solve the misbehaving condition.\n\n\u003e My suggestion would be to define Recover-(Lost)-Reindex-Event strategy in this plugin and add additional strategies when different strategies are implemented:\n\u003e \n\u003e * Full table scan\n\nThis takes around 1usec per change, which means a max of 3-4sec for Hugo\u0027s case (over 3M changes). Seems like a reasonable overhead to me. A full reindex would take hours anyway, so 3s is definitely better that 3h to me :-)\n\n\u003e * Full ref scan\n\nThat may take a while, let me do a quick test on it.\nHowever, the refs are not enough to say that the change is there. A misbehaving master could have stored the ref but not the row into the changes table.\n\n\u003e * Stadalone Queue\n\nThat would add one extra point of failure: the queue.\n\n\u003e * Query active node\n\nThe active node is dead or misbehaving: we cannot rely on it.\n\n\u003e * reindex-event-recorder-plugin\n\nYep, good idea.",
      "parentUuid": "7d14de30_16545a14",
      "range": {
        "startLine": 45,
        "startChar": 11,
        "endLine": 45,
        "endChar": 29
      },
      "revId": "1135b2eff5759be9af24f5866b0f7234028fd0ba",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}