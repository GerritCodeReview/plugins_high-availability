{
  "comments": [
    {
      "key": {
        "uuid": "cf29b9a4_19571e62",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/forwarder/ForwardedIndexChangeHandler.java",
        "patchSetId": 19
      },
      "lineNbr": 162,
      "author": {
        "id": 1012987
      },
      "writtenOn": "2018-06-14T12:48:18Z",
      "side": 1,
      "message": "I understand the idea, i.e check if change TS is older after indexing than the TS of the forwarded indexing event this means that we got stale info from repo and we need to retry. I know this is not exactly what is implemented(you do this check before indexing) but both ways, this will cause a lot of unneeded retries.\n\nThis idea would work if every cause of indexing in Gerrit would be associated with the change TS being updated but this is not the case. First example is ReindexAfterRefUpdate which will reindex all the open changes on a branch after ref update on that branch. In this case, all the open changes are reindexed to update mergeability flag but the TS of the change is not updated. Another example, if someone manually index change(s) by calling Gerrit REST API to index a change, this will not update the TS.\n\nWhat will happen is retries will be done even if there is no issue. The manual indexing is marginal so we could have accepted the uneeded retries in that case but ReindexAfterRefUpdate will cause massive unneeded retries.",
      "range": {
        "startLine": 156,
        "startChar": 2,
        "endLine": 162,
        "endChar": 1
      },
      "revId": "d36ffff9751cdd58fce95485b86dcdd5528234bd",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de74a00e_dd0cacba",
        "filename": "src/main/java/com/ericsson/gerrit/plugins/highavailability/forwarder/ForwardedIndexChangeHandler.java",
        "patchSetId": 19
      },
      "lineNbr": 162,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2018-06-14T13:36:55Z",
      "side": 1,
      "message": "\u003e I understand the idea, i.e check if change TS is older after indexing than the TS of the forwarded indexing event this means that we got stale info from repo and we need to retry. I know this is not exactly what is implemented(you do this check before indexing) but both ways, this will cause a lot of unneeded retries.\n\nThe idea is to check the \u0027change TS\u0027 *before* doing the indexing. The reindex is *very* intensive in terms of CPU and resources and it is way better to avoid doing it if it is not needed.\nRetrying is a lot cheaper than reindexing.\n\nA full reindex of the all projects would take hours. A reindex of a single project no less than 5 minutes.\n\n\u003e This idea would work if every cause of indexing in Gerrit would be associated with the change TS being updated but this is not the case. First example is ReindexAfterRefUpdate which will reindex all the open changes on a branch after ref update on that branch. \n\nGood catch. So basically we should get the last update of the target branch as well. Good point, let me add this into the change.\n\n\u003e In this case, all the open changes are reindexed to update mergeability flag but the TS of the change is not updated. \n\nSure, and I believe I can catch that case easily.\n\n\u003e Another example, if someone manually index change(s) by calling Gerrit REST API to index a change, this will not update the TS.\n\nThis is the reindexing scenario: in this case *NO* we don\u0027t want to reindex on the other nodes as well. I have raised a case for that.\n\nIf we propagate the reindex events (the manual ones) we literally *kill* the secondary node. You manually reindex when something is wrong. I use the manual reindex *exactly* to fix the misalignments between nodes automatically. Unfortunately, at the moment, it propagates the reindex event on the other node and generates a lot of noise of unneeded traffic and CPU load.\n\n\u003e What will happen is retries will be done even if there is no issue. The manual indexing is marginal so we could have accepted the uneeded retries in that case but ReindexAfterRefUpdate will cause massive unneeded retries.\n\nThe un-needed retries are cheap, the unneeded reindex are *very expensive*.",
      "parentUuid": "cf29b9a4_19571e62",
      "range": {
        "startLine": 156,
        "startChar": 2,
        "endLine": 162,
        "endChar": 1
      },
      "revId": "d36ffff9751cdd58fce95485b86dcdd5528234bd",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}